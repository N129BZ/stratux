package main

import (
	"database/sql"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
)

type Flightlog struct {
	LogId       int64
	LogName     string
	StartTs     string
	EndTs       string

	HasSituation bool
	HasStatus    bool
	HasTraffic   bool
}

type TimestampSituation struct {
	*StratuxTimestamp
	*SituationData
}

type TimestampTraffic struct {
	*StratuxTimestamp
	*TrafficInfo
}


type DbFlightLog struct {
	db *sqlx.DB
}


var flightLogInstance *DbFlightLog
func GetDbFlightLog() (*DbFlightLog, error) {
	var err error
	if flightLogInstance == nil {
		flightLogInstance = &DbFlightLog{}
		err = flightLogInstance.OpenDb()
	}
	return flightLogInstance, err
}

func (this *DbFlightLog) OpenDb() error {
	if this.db != nil {
		return nil
	}
	sqldb, err := sql.Open("sqlite3", dataLogFilef)
	if err != nil {
		addSingleSystemErrorf("Unable to open flight log database %s", dataLogFilef)
		return err
	}
	InitDbFlightlog(sqldb)
	// Unsafe, so missing fields are silently ignored
	this.db = sqlx.NewDb(sqldb, "sqlite3").Unsafe()
	this.db.MapperFunc(func (s string) string { 
		// otherwise sqlx calls toLower to map fileds to struct members.. Also don't report unexported fields
		return s
	}) 
	this.db.Exec("PRAGMA foreign_keys = ON")
	return nil
}


// Fetches all MySituations for the respective boot
func (this *DbFlightLog) getMyTrack(bootid int) (chan *TimestampSituation, error) {
	rows, err := this.db.Queryx(`
		SELECT * FROM timestamp INNER JOIN mySituation ON timestamp.id=mySituation.timestamp_id
			WHERE StartupId=? AND SystemClock_value != ''
		ORDER BY StratuxClock_value`, bootid)

	if err != nil {
		return nil, err
	}
	resChan := make(chan *TimestampSituation, 1000)
	go func() {
		defer rows.Close()
		for rows.Next() {
			var sit TimestampSituation
			rows.StructScan(&sit)
			resChan <- &sit
		}
		close(resChan)
	}()
	return resChan, nil
}

func (this *DbFlightLog) getTrafficTracks(bootid int) (chan *TimestampTraffic, error) {
	rows, err := this.db.Queryx(`
		SELECT * FROM timestamp INNER JOIN traffic ON timestamp.id=traffic.timestamp_id
			WHERE StartupId=? AND SystemClock_value != '' AND traffic.Position_valid=1
		ORDER BY traffic.Icao_addr, timestamp_id
	`, bootid)
	if err != nil {
		return nil, err
	}
	
	resChan := make(chan *TimestampTraffic, 1000)
	go func() {
		defer rows.Close()
		for rows.Next() {
			var ti TimestampTraffic
			rows.StructScan(&ti)
			resChan <- &ti
		}
		close(resChan)
	}()
	return resChan, nil
}

func (this *DbFlightLog) formatTime(ts time.Time) string {
	return ts.Format("2006-01-02T15:04:05.999Z")
}

func (this *DbFlightLog) ExportGpx(bootid int, includeTraffic bool, dst io.Writer) error {
	dst.Write([]byte("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n"))
	dst.Write([]byte("<gpx version=\"1.1\" creator=\"Stratux\">\n"))
	dst.Write([]byte("<metadata>Generated by Stratux</metadata>\n")) // TODO: export info...
	dst.Write([]byte("<trk>\n"))
	dst.Write([]byte("<name>Ownship</name>\n"))
	dst.Write([]byte("<trkseg>\n"))

	sitChan, err := this.getMyTrack(bootid)
	if err != nil {
		return err
	}
	geoidSeparation := float32(0.0) // remember to convert traffic with correct sparation
	for situation := range sitChan {
		if situation.GPSLatitude == 0 && situation.GPSLongitude == 0 {
			continue
		}
		geoidSeparation = situation.GPSGeoidSep
		dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", situation.GPSLatitude, situation.GPSLongitude)))
		dst.Write([]byte(fmt.Sprintf("<ele>%f</ele>", situation.GPSAltitudeMSL / 3.28084)))
		dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(situation.SystemClock_value))))
		dst.Write([]byte("</trkpt>\n"))
	}

	dst.Write([]byte("</trkseg>\n"))
	dst.Write([]byte("</trk>\n"))

	if includeTraffic {
		var prevTi *TimestampTraffic
		trafficChan, err := this.getTrafficTracks(bootid)
		if err != nil {
			return err
		}
		for ti := range trafficChan {
			if !ti.Position_valid {
				continue
			}
			if prevTi == nil || prevTi.Icao_addr != ti.Icao_addr || ti.Timestamp.Sub(prevTi.Timestamp) > 60 * time.Second {
				// beginning of new target
				if prevTi != nil {
					dst.Write([]byte("</trkseg></trk>\n"))
				}
				// Next target or same target received again after a while -- start new track
				dst.Write([]byte("<trk>"))
				name := fmt.Sprintf("%.6X", ti.Icao_addr & 0xFFFFFF)
				if ti.Tail != "" {
					name += " (" + ti.Tail + ")"
				}
				dst.Write([]byte("<name>" + name + "</name>"))
				dst.Write([]byte("<src>" + strconv.Itoa(int(ti.Last_source)) + "</src>"))
				dst.Write([]byte("<trkseg>\n"))
			}
			if prevTi != nil && prevTi.Lat == ti.Lat && prevTi.Lng == ti.Lng {
				continue // target not moved.. skip
			}
			dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", ti.Lat, ti.Lng)))
			if ti.AltIsGNSS {
				dst.Write([]byte(fmt.Sprintf("<ele>%f</ele>", float32(ti.Alt) / 3.28084)))
			} else {
				dst.Write([]byte(fmt.Sprintf("<ele>%f</ele>", float32(ti.Alt + ti.GnssDiffFromBaroAlt + int32(geoidSeparation)) / 3.28084)))
			}
			dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(ti.SystemClock_value))))
			dst.Write([]byte("</trkpt>\n"))
			prevTi = ti
		}
		if prevTi != nil {
			// end traffic section
			dst.Write([]byte("</trkseg></trk>\n"))
		}
	}
	dst.Write([]byte("</gpx>\n"))
	return nil
}

func (this *DbFlightLog) ExportIgc(bootid int, dst io.Writer) error {
	return this.ExportGpx(bootid, false, dst)
}

func (this *DbFlightLog) ExportKml(bootid int, includeTraffic bool, dst io.Writer) error {
	return this.ExportGpx(bootid, includeTraffic, dst)
}

func (this *DbFlightLog) GetLogList() ([]Flightlog, error) {
	rows, err := this.db.Queryx(`
		SELECT startup.id AS LogId, startup.logname AS LogName, MIN(SystemClock_value) AS StartTs, MAX(SystemClock_value) AS EndTs,
			MIN(traffic.timestamp_id) IS NOT NULL AS HasTraffic, MIN(mysituation.timestamp_id) IS NOT NULL AS HasSituation, MIN(status.timestamp_id) IS NOT NULL AS HasStatus
			FROM startup
		INNER JOIN timestamp ts ON ts.SystemClock_value != '' AND ts.StartupID=startup.id
		LEFT JOIN traffic ON traffic.timestamp_id = ts.id
		LEFT JOIN mysituation ON mysituation.timestamp_id = ts.id
		LEFT JOIN status ON status.timestamp_id = ts.id
		GROUP BY startup.id
	`)
	if err != nil {
		return nil, err
	}
	logs := make([]Flightlog, 0)
	defer rows.Close()
	for rows.Next() {
		var log Flightlog
		rows.StructScan(&log)
		logs = append(logs, log)
	}
	return logs, nil
}

func (this *DbFlightLog) SetLogName(id int, name string) error {
	_, err := this.db.Exec("UPDATE startup SET LogName=? WHERE id=?", name, id)
	return err
}

// Deletes the requested log, including all entries (via ON DELETE CASCADE)
func (this *DbFlightLog) DeleteLog(id int) error {
	_, err := this.db.Exec("DELETE FROM startup WHERE id=?", id)
	return err
}