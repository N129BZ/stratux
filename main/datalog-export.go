package main

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/jmoiron/sqlx"
	_ "github.com/mattn/go-sqlite3"
)

type Flightlog struct {
	LogId       int64
	StartTs     string
	EndTs       string
}

type TimestampSituation struct {
	*StratuxTimestamp
	*SituationData
}

type TimestampTraffic struct {
	*StratuxTimestamp
	*TrafficInfo
}


type DbFlightLog struct {
	db *sqlx.DB
}


var flightLogInstance *DbFlightLog
func GetDbFlightLog() (*DbFlightLog, error) {
	var err error
	if flightLogInstance == nil {
		flightLogInstance = &DbFlightLog{}
		err = flightLogInstance.OpenDb()
	}
	return flightLogInstance, err
}

func (this *DbFlightLog) OpenDb() error {
	if this.db != nil {
		return nil
	}
	var err error
	this.db, err = sqlx.Open("sqlite3", dataLogFilef)
	if err != nil {
		addSingleSystemErrorf("Unable to open flight log database %s", dataLogFilef)
		return err
	}
	this.db = this.db.Unsafe() // so missing fields are silently ignored
	this.db.MapperFunc(func (s string) string { 
		// otherwise sqlx calls toLower to map fileds to struct members.. Also don't report unexported fields
		return s
	}) 
	return nil
}


// Fetches all MySituations for the respective boot
func (this *DbFlightLog) getMyTrack(bootid int, resultCb func(TimestampSituation)) error {
	rows, err := this.db.Queryx(`
		SELECT * FROM timestamp INNER JOIN mySituation ON timestamp.id=mySituation.timestamp_id
			WHERE StartupId=? AND SystemClock_value != ''
		ORDER BY StratuxClock_value`, bootid)

	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		var sit TimestampSituation
		rows.StructScan(&sit)
		resultCb(sit)
	}
	return nil
}

func (this *DbFlightLog) getTrafficTracks(bootid int, resultCb func(TimestampTraffic)) error {
	rows, err := this.db.Queryx(`
	SELECT * FROM timestamp INNER JOIN traffic ON timestamp.id=traffic.timestamp_id
		WHERE StartupId=? AND SystemClock_value != ''
	ORDER BY traffic.Icao_addr, timestamp_id
	`, bootid)
	if err != nil {
		return err
	}
	defer rows.Close()
	for rows.Next() {
		var ti TimestampTraffic
		rows.StructScan(&ti)
		resultCb(ti)
	}
	return nil
}

func (this *DbFlightLog) formatTime(ts time.Time) string {
	return ts.Format("2006-01-02T15:04:05.999Z")
}

func (this *DbFlightLog) ExportGpx(bootid int, dst io.Writer) error {
	dst.Write([]byte("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n"))
	dst.Write([]byte("<gpx version=\"1.1\" creator=\"Stratux\">\n"))
	dst.Write([]byte("<metadata>Generated by Stratux</metadata>\n")) // TODO: export info...
	dst.Write([]byte("<trk>\n"))
	dst.Write([]byte("<name>Ownship</name>\n"))
	dst.Write([]byte("<trkseg>\n"))

	this.getMyTrack(bootid, func(situation TimestampSituation) {
		if situation.GPSLatitude == 0 && situation.GPSLongitude == 0 {
			return
		}
		dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", situation.GPSLatitude, situation.GPSLongitude)))
		dst.Write([]byte(fmt.Sprintf("<ele>%f</ele>", situation.GPSAltitudeMSL)))
		dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(situation.SystemClock_value))))
		dst.Write([]byte("</trkpt>\n"))
	})

	dst.Write([]byte("</trkseg>\n"))
	dst.Write([]byte("</trk>\n"))

	var prevTi *TimestampTraffic
	this.getTrafficTracks(bootid, func(ti TimestampTraffic) {
		if !ti.Position_valid {
			return
		}
		if prevTi == nil || prevTi.Icao_addr != ti.Icao_addr || ti.Timestamp.Sub(prevTi.Timestamp) > 20 * time.Second {
			// beginning of new target
			if prevTi != nil {
				dst.Write([]byte("</trkseg></trk>\n"))
			}
			// Next target or same target received again after a while -- start new track
			dst.Write([]byte("<trk>"))
			name := fmt.Sprintf("%.6X", ti.Icao_addr & 0xFFFFFF)
			if ti.Tail != "" {
				name += " (" + ti.Tail + ")"
			}
			dst.Write([]byte("<name>" + name + "</name>"))
			dst.Write([]byte("<src>" + strconv.Itoa(int(ti.Last_source)) + "</src>"))
			dst.Write([]byte("<trkseg>\n"))
		}
		if prevTi != nil && prevTi.Lat == ti.Lat && prevTi.Lng == ti.Lng {
			return // target not moved.. skip
		}
		dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", ti.Lat, ti.Lng)))
		if ti.AltIsGNSS {
			dst.Write([]byte(fmt.Sprintf("<ele>%d</ele>", ti.Alt)))
		} else {
			dst.Write([]byte(fmt.Sprintf("<ele>%d</ele>", ti.Alt + ti.GnssDiffFromBaroAlt)))
		}
		dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(ti.SystemClock_value))))
		dst.Write([]byte("</trkpt>\n"))
		prevTi = &ti
	})
	if prevTi != nil {
		// end traffic section
		dst.Write([]byte("</trkseg></trk>\n"))
	}
	dst.Write([]byte("</gpx>\n"))
	return nil
}

func (this *DbFlightLog) ExportIgc(bootid int, dst io.Writer) error {
	return this.ExportGpx(bootid, dst)
}

func (this *DbFlightLog) ExportKml(bootid int, dst io.Writer) error {
	dst.Write([]byte("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n"))
	dst.Write([]byte("<gpx version=\"1.1\" creator=\"Stratux\">\n"))
	dst.Write([]byte("<metadata>Generated by Stratux</metadata>\n")) // TODO: export info...
	dst.Write([]byte("<trk>\n"))
	dst.Write([]byte("<name>Ownship</name>\n"))
	dst.Write([]byte("<trkseg>\n"))

	this.getMyTrack(bootid, func(situation TimestampSituation) {
		if situation.GPSLatitude == 0 && situation.GPSLongitude == 0 {
			return
		}
		dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", situation.GPSLatitude, situation.GPSLongitude)))
		dst.Write([]byte(fmt.Sprintf("<ele>%f</ele>", situation.GPSAltitudeMSL)))
		dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(situation.SystemClock_value))))
		dst.Write([]byte("</trkpt>\n"))
	})

	dst.Write([]byte("</trkseg>\n"))
	dst.Write([]byte("</trk>\n"))

	var prevTi *TimestampTraffic
	this.getTrafficTracks(bootid, func(ti TimestampTraffic) {
		if !ti.Position_valid {
			return
		}
		if prevTi == nil || prevTi.Icao_addr != ti.Icao_addr || ti.Timestamp.Sub(prevTi.Timestamp) > 20 * time.Second {
			// beginning of new target
			if prevTi != nil {
				dst.Write([]byte("</trkseg></trk>\n"))
			}
			// Next target or same target received again after a while -- start new track
			dst.Write([]byte("<trk>"))
			name := fmt.Sprintf("%.6X", ti.Icao_addr & 0xFFFFFF)
			if ti.Tail != "" {
				name += " (" + ti.Tail + ")"
			}
			dst.Write([]byte("<name>" + name + "</name>"))
			dst.Write([]byte("<src>" + strconv.Itoa(int(ti.Last_source)) + "</src>"))
			dst.Write([]byte("<trkseg>\n"))
		}
		if prevTi != nil && prevTi.Lat == ti.Lat && prevTi.Lng == ti.Lng {
			return // target not moved.. skip
		}
		dst.Write([]byte(fmt.Sprintf("<trkpt lat=\"%f\" lon=\"%f\">", ti.Lat, ti.Lng)))
		if ti.AltIsGNSS {
			dst.Write([]byte(fmt.Sprintf("<ele>%d</ele>", ti.Alt)))
		} else {
			dst.Write([]byte(fmt.Sprintf("<ele>%d</ele>", ti.Alt + ti.GnssDiffFromBaroAlt)))
		}
		dst.Write([]byte(fmt.Sprintf("<time>%s</time>", this.formatTime(ti.SystemClock_value))))
		dst.Write([]byte("</trkpt>\n"))
		prevTi = &ti
	})
	if prevTi != nil {
		// end traffic section
		dst.Write([]byte("</trkseg></trk>\n"))
	}
	dst.Write([]byte("</gpx>\n"))
	return nil
}

func (this *DbFlightLog) GetLogList() ([]Flightlog, error) {
	rows, err := this.db.Queryx(`
		SELECT startup.id AS LogId, datetime(MIN(SystemClock_value)/1000, 'unixepoch') AS StartTs, datetime(MAX(SystemClock_value)/1000, 'unixepoch') AS EndTs
			FROM startup
		INNER JOIN timestamp t1 on t1.SystemClock_value != '' and t1.StartupID=startup.id
		GROUP BY startup.id
	`)
	if err != nil {
		return nil, err
	}
	logs := make([]Flightlog, 0)
	defer rows.Close()
	for rows.Next() {
		var log Flightlog
		rows.StructScan(&log)
		logs = append(logs, log)
	}
	return logs, nil
}